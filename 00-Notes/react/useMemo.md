## useMemo

``` jsx

<app>
 <A>
    <B></B>
 </A>
</app>

```
- 当A组件重新渲染时，A的子组件B也会跟着重新渲染
- 为了避免B组件不必要的重新渲染，我们可以给B组件包装useMemo()
- 只有B组件的props变化时才会重新渲染B，否则总是返回缓存中的结果
- 如果B没有使用props，则外部的组件变化不会触发B的渲染

``` jsx

export default React.memo(B);

```


注意事项
依赖数组必须完整：计算函数中使用的所有外部变量（如示例中的 users）都必须包含在依赖数组中，否则可能导致缓存的结果过时（使用旧值计算）。
不要过度使用：对于简单的计算（如 a + b），使用 useMemo 反而会增加性能开销（缓存本身需要成本），此时直接计算更高效。
与 useCallback 的区别：useMemo 缓存的是计算结果，而 useCallback 缓存的是函数引用，两者都是为了避免不必要的重复执行 / 创建。
总结：useMemo 是 React 提供的性能优化工具，核心是通过缓存计算结果，减少组件渲染时的重复计算，适用于处理昂贵的计算逻辑。